#ifndef SURFACEPOINT_H
#define SURFACEPOINT_H

#include "object.h"
#include "rtmath.h"

namespace RenderToy
{
    class SurfacePoint
    {
    public:
        SurfacePoint(const Triangle *triangle_, const Vector3f &position_, const float u_, const float v_);

        /// @brief Get radiosity generated by an emissive triangle.
        /// @param to_pos
        /// @param out_dir
        /// @param is_solid_angle If set TRUE, we consider the triangle as a face rather than a point (when setting to FALSE).
        /// @return
        template <bool is_solid_angle>
        const Vector3f GetEmission(const Vector3f &to_pos, const Vector3f &out_dir, float &pdf) const
        {
            /*             current point
            emitter    ----*----
                            \
                             \
                              \ out_dir
                               \
                                v
                             ----*----     receiver
                                  to_pos
            */
            const Vector3f ray(to_pos - position);
            const float distance2 = ray.Dot(ray);
            const float cos_area = out_dir.Dot(GetNormal()) * triangle->AreaC();
            if constexpr (is_solid_angle)
            {
                pdf = std::abs(distance2 / cos_area);
            }
            else
            {
                pdf = distance2;
            }
            return triangle->parent->tex->emission;
        }

        const Triangle *GetHitTriangle();
        const Triangle *GetHitTriangle() const;
        Vector3f &GetPosition();
        const Vector3f &GetPosition() const;
        const Mesh *GetHitMesh() const;
        const PrincipledBSDF *GetMaterial() const;
        const Vector3f GetNormal() const;
        const Vector3f GetGeometricalNormal() const;

    private:
        const Triangle *triangle;
        Vector3f position;
        float u, v;
    };
}

#endif // SURFACEPOINT_H